#!/usr/bin/env python

"""kdenclip

Usage:
  kdenclip <projectfile> [options]
  kdenclip -h | --help
  kdenclip --version

Extract video clips from a kdenlive project file.

Examples:
  kdenclip project.kdenlive
  kdenclip project.kdenlive -o /savepath/for/clips

Options:
  -o <outpath>   Specify output path for clips
  -q, --quiet    Print less text
  -v, --verbose  Print more text
  -h, --help     Show help
  --version      Show version
"""

__appname__ = "kdenclip"
__author__  = "David Maranhao"
__license__ = "MIT"
__version__ = "1.0.0" # MAJOR.MINOR.PATCH | http://semver.org


from docopt import docopt
from bs4 import BeautifulSoup
import re
import subprocess
import os
import logging


def main():
    args = docopt(__doc__, version="kdenclip v{}".format(__version__))

    # Process required command line arguments
    projectFile = os.path.abspath(os.path.expanduser(args['<projectfile>']))
    outPath = os.path.abspath(os.path.expanduser(os.getcwd()))
    if args['-o']:
        outPath = args['-o']

    # Configure logging
    logLevel = logging.INFO #default
    if args['--verbose']:
        logLevel = logging.DEBUG
    elif args['--quiet']:
        logLevel = logging.ERROR

    logging.basicConfig(format='%(levelname)s: %(message)s', level=logLevel)
    logging.debug(args)

    if not os.path.exists(projectFile):
        logging.error("projectfile argument '%s' isn't a file" % projectFile)
        return
    if not os.path.isdir(outPath):
        logging.error("outpath argument '%s' isn't a directory" % outPath)
        return

    kdenProject = KdenliveProject(projectFile)
    kdenProject.exportClips(outPath)

    return


class KdenliveProject():

    def __init__(self, projectFile):
        self.parseProject(projectFile)

    def parseProject(self, projectFile):
        self.clips = []
        self.errorCount = 0
        self.projectFile = projectFile

        logging.info("\nParsing kdenlive project %s ..." % projectFile)

        # Soupify XML
        soup = BeautifulSoup(open(self.projectFile),'lxml')

        # Parse framerate
        frameRateDen = float(soup.profile['frame_rate_den'])
        frameRateNum = float(soup.profile['frame_rate_num'])
        frameRate = float(frameRateNum / frameRateDen)
        logging.debug("frameRate:\t%d" % frameRate)
        # TODO: check that frameRate was parsed properly

        # Parse clip data from kdenlive project file
        for producer in soup.find_all('producer'):
            logging.debug("producer:\t%s" % producer)
            if producer['id'] == 'black':
                continue

            producerID = producer['id']
            resource = producer.find('property',attrs={'name': 'resource'}).string

            # in 15.08 project file change, resource is SOMETIMES absolute.
            # Not sure the rules for this, but for now assume its relative to $HOME if pathname does not start with / (what about windows?)
            if not os.path.isabs(resource):
                resource = os.path.join(os.path.expanduser('~'),resource)

            #name = producer.find('property',attrs={'name': 'kdenlive:clipname'}).string # Not reliable anymore.. some producers don't have this property for unknown reasons.
            name = os.path.split(resource)[1]

            logging.debug("producerID: %s;\tname: %s;\tresource: %s" % (producerID, name, resource))

            # kdenlive identifies producers as <clipid>_<track> or
            # just <clipid> when on first track
            regex = "^%s_|^%s$" % (producerID, producerID)
            for clip in soup.find_all('entry', producer=re.compile(regex)):
                logging.debug("clip: %s" % clip)
                if (clip['producer'] == 'black' or
                        clip.parent.attrs['id'] == 'main bin'):
                    continue

                startFrame = int(clip['in'])
                endFrame = int(clip['out'])
                startSeconds = startFrame / frameRate
                endSeconds = endFrame / frameRate
                durationFrames = endFrame - startFrame
                durationSeconds = endSeconds - startSeconds

                self.clips.append({
                    'id': producerID,
                    'name': name,
                    'resource': resource,
                    'startFrame': startFrame,
                    'endFrame': endFrame,
                    'durationFrames': durationFrames,
                    'startSeconds': startSeconds,
                    'endSeconds': endSeconds,
                    'durationSeconds': durationSeconds
                })

        logging.info("\n---")
        logging.info("Finished parsing %d clips from %s" % (len(self.clips), projectFile))


    def exportClips(self, outPath):

        for clip in self.clips:
            # break file into name and extension
            m = re.search(r"(.+)\.(.+)$", clip['name'])
            if m:
                fileName = m.group(1)
                fileExtension = ".{}".format(m.group(2))
            else:
                logging.error("could not parse file extension of '%s'" % clip['name'])
                fileName = clip['name']
                fileExtension = ""

            outFileName = "%s-%d-%d%s" % (fileName, int(clip['startSeconds']), int(clip['endSeconds']), fileExtension)
            outFileNamePath = os.path.join(outPath, outFileName)
            ffmpegCommandLine = ['ffmpeg', '-y', '-i', clip['resource'], '-ss', '%0.3f' % clip['startSeconds'], '-t', '%0.3f' % clip['durationSeconds'], '-c', 'copy', outFileNamePath]
            logging.debug("ffmpegCommandLine: %s" % str(ffmpegCommandLine))

            proc = subprocess.Popen(ffmpegCommandLine)
            proc.wait()
            if proc.returncode != 0:
                self.errorCount += 1

        logging.info("\n---")
        logging.info("Finished exporting %d clips from %s" % (len(self.clips), self.projectFile))
        logging.info("  %d errors occured" % self.errorCount)


if __name__ == "__main__":
    main()
