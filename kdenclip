#!/usr/bin/env python

"""kdenclip

Usage:
  kdenclip <projectfile> [options]
  kdenclip -h | --help
  kdenclip --version

Extract video clips from a kdenlive project file.

Examples:
  kdenclip project.kdenlive
  kdenclip project.kdenlive -o /savepath/for/clips

Options:
  -o <outpath>   Specify output path for clips
  -q, --quiet    Print less text
  -v, --verbose  Print more text
  -h, --help     Show help
  --version      Show version
"""

__appname__ = "kdenclip"
__author__  = "David Maranhao"
__license__ = "MIT"
__version__ = "1.0.0" # MAJOR.MINOR.PATCH | http://semver.org


from docopt import docopt
from bs4 import BeautifulSoup
import re
import subprocess
import os
import logging

def main():
    args = docopt(__doc__, version="kdenclip v{}".format(__version__))

    # Process required command line arguments
    projectFile = os.path.abspath(os.path.expanduser(args['<projectfile>']))
    outPath = os.path.abspath(os.path.expanduser(os.getcwd()))
    if args['-o']:
        outPath = args['-o']

    # Configure logging
    logLevel = logging.INFO #default
    if args['--verbose']:
        logLevel = logging.DEBUG
    elif args['--quiet']:
        logLevel = logging.ERROR

    logger.setLevel(logLevel)
    logger.debug(args)

    if not os.path.exists(projectFile):
        logger.error("projectfile argument '%s' isn't a file" % projectFile)
        return
    if not os.path.isdir(outPath):
        logger.error("outpath argument '%s' isn't a directory" % outPath)
        return

    kdenProject = KdenliveProject(projectFile)
    kdenProject.exportClips(outPath)

    return


class KdenliveProject():

    def __init__(self, projectFile):
        self.parseProject(projectFile)

    def parseProject(self, projectFile):
        self.clips = []
        self.errorCount = 0
        self.projectFile = projectFile

        logger.info("\nParsing kdenlive project %s ..." % projectFile)

        # Soupify XML
        soup = BeautifulSoup(open(self.projectFile),'lxml')

        # Parse framerate
        frameRateDen = float(soup.profile['frame_rate_den'])
        frameRateNum = float(soup.profile['frame_rate_num'])
        self.frameRate = float(frameRateNum / frameRateDen)
        logger.debug("frameRate:\t%d" % self.frameRate)
        # TODO: check that frameRate was parsed properly

        # Parse project data
        self.title = soup.mlt['title']
        self.version = soup.mlt['version']
        self.root = soup.mlt['root']

        logger.info("\nTitle   : %s" % self.title)
        logger.info("Version : %s" % self.version)
        logger.info("Root    : %s" % self.root)

        #TODO: Handle multiple versions

        # Parse clip data from kdenlive project file
        for producer in soup.find_all('producer'):
            logger.debug("producer:\t%s" % producer['id'])
            if producer['id'] == 'black':
                continue

            producerID = producer['id']
            resource = producer.find('property',attrs={'name': 'resource'}).string

            # in 15.08 project file change, resource is SOMETIMES absolute.
            if not os.path.isabs(resource):
                resource = os.path.join(os.path.expanduser(self.root),resource)

            #name = producer.find('property',attrs={'name': 'kdenlive:clipname'}).string # Not reliable anymore.. some producers don't have this property for unknown reasons.
            name = os.path.split(resource)[1]

            logger.debug("producerID: %s;\tname: %s;\tresource: %s" % (producerID, name, resource))

            # kdenlive identifies producers as <clipid>_<track> or
            # just <clipid> when on first track
            regex = "^%s_|^%s$" % (producerID, producerID)
            for clip in soup.find_all('entry', producer=re.compile(regex)):
                #logger.debug("clip: %s" % clip)
                if (clip['producer'] == 'black' or
                        clip.parent.attrs['id'] == 'main bin'):
                    continue

                startFrame = int(clip['in'])
                endFrame = int(clip['out'])
                startSeconds = startFrame / self.frameRate
                endSeconds = endFrame / self.frameRate
                durationFrames = endFrame - startFrame
                durationSeconds = endSeconds - startSeconds

                self.clips.append({
                    'id': producerID,
                    'name': name,
                    'resource': resource,
                    'startFrame': startFrame,
                    'endFrame': endFrame,
                    'durationFrames': durationFrames,
                    'startSeconds': startSeconds,
                    'endSeconds': endSeconds,
                    'durationSeconds': durationSeconds
                })

        logger.info("\nFinished parsing %d clips from %s" % (len(self.clips), projectFile))
        logger.info("\n---")


    def exportClips(self, outPath):

        for clip in self.clips:
            # break file into name and extension
            m = re.search(r"(.+)\.(.+)$", clip['name'])
            if m:
                fileName = m.group(1)
                fileExtension = ".{}".format(m.group(2))
            else:
                logger.error("could not parse file extension of '%s'" % clip['name'])
                fileName = clip['name']
                fileExtension = ""

            outFileName = "%s-%d-%d%s" % (fileName, int(clip['startSeconds']), int(clip['endSeconds']), fileExtension)
            outFileNamePath = os.path.join(outPath, outFileName)
            ffmpegCommandLine = ['ffmpeg', '-y', '-i', clip['resource'], '-ss', '%0.3f' % clip['startSeconds'], '-t', '%0.3f' % clip['durationSeconds'], '-c', 'copy', outFileNamePath]
            logger.debug("ffmpegCommandLine: %s" % str(ffmpegCommandLine))

            proc = subprocess.Popen(ffmpegCommandLine)
            proc.wait()
            if proc.returncode != 0:
                self.errorCount += 1

        logger.info("\n---")
        logger.info("Finished exporting %d clips from %s" % (len(self.clips), self.projectFile))
        logger.info("  %d errors occured" % self.errorCount)


# Custom formatter
class LogFormatter(logging.Formatter):

    def __init__(self, fmt="%(levelname)s: %(message)s"):
        logging.Formatter.__init__(self, fmt)

    def format(self, record):
        origFormat = self._fmt

        # Replace the original format with one customized by logging level
        if record.levelno == logging.DEBUG:
            self._fmt = "DEBUG: %(module)s: %(lineno)d: %(message)s"
        elif record.levelno == logging.INFO:
            self._fmt = "%(message)s"
        elif record.levelno == logging.ERROR:
            self._fmt = "ERROR: %(message)s"

        self._style = logging.PercentStyle(self._fmt)

        # Call the original formatter class to do the grunt work
        result = logging.Formatter.format(self, record)

        # Restore the original format configured by the user
        self._fmt = origFormat

        return result


logger = logging.getLogger('kdenclip')
ch = logging.StreamHandler(os.sys.stdout)
fmt = LogFormatter()
ch.setFormatter(fmt)
logger.addHandler(ch)

if __name__ == "__main__":
    main()
