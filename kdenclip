#!/usr/bin/env python

"""kdenclip

Usage:
  kdenclip <projectfile> [options]
  kdenclip -h | --help
  kdenclip --version

Extract video clips from a kdenlive project file.

Examples:
  kdenclip project.kdenlive
  kdenclip project.kdenlive -o /savepath/for/clips

Options:
  -o <outpath>   Specify output path for clips
  -q, --quiet    Print less text
  -v, --verbose  Print more text
  -h, --help     Show help
  --version      Show version
"""

__appname__ = "kdenclip"
__author__  = "David Maranhao"
__license__ = "MIT"
__version__ = "1.0.0" # MAJOR.MINOR.PATCH | http://semver.org


from docopt import docopt
from bs4 import BeautifulSoup
import re
import subprocess
import os
import logging


def main():
    args = docopt(__doc__, version="kdenclip v{}".format(__version__))

    # Process required command line arguments
    projectFile = os.path.abspath(os.path.expanduser(args['<projectfile>']))
    outPath = os.path.abspath(os.path.expanduser(os.getcwd()))
    if args['-o']:
        outPath = args['-o']

    # Configure logging
    logLevel = logging.INFO #default
    if args['--verbose']:
        logLevel = logging.DEBUG
    elif args['--quiet']:
        logLevel = logging.ERROR

    logging.basicConfig(format='%(levelname)s: %(message)s', level=logLevel)
    logging.debug(args)

    if not os.path.exists(projectFile):
        logging.error("projectfile argument '%s' isn't a file" % projectFile)
        return
    if not os.path.isdir(outPath):
        logging.error("outpath argument '%s' isn't a directory" % outPath)
        return

    extractClips = ExtractClips(projectFile, outPath)
    logging.info("\nParsing kdenlive project %s ..." % projectFile)
    extractClips.parse()
    clips = extractClips.getClips()
    errorCount = extractClips.getErrorCount()
    # Report on completion
    logging.info("\n---")
    logging.info("Finished extracting clips from %s" % projectFile)
    logging.info("  %d clip operations performed" % len(clips))
    logging.info("  %d errors occured" % errorCount)

    return


class ExtractClips():
    """Instances parse the kdenlive project file denoted by inFileName
    and extract the clips of the project with `ffmpeg` into the
    directory denoted by outPath."""

    def __init__(self, inFileName, outPath):
        """Creates an instance of ExtractClips which can be used mainly
        with its parse function. It expects inFileName and outPath to
        exist."""
        self.clips = []
        self.errorCount = 0
        self.inFileName = inFileName
        self.outPath = outPath

    def parse(self):
        """parses the file denoted by the class property inFilePath and
        writes result into the directory denoted by outPath. The
        results can be retrieved from the clips property. The number of
        errors encountered are stored into the errorCount property.
        Instances are not reusable."""
        # Soupify XML
        soup = BeautifulSoup(open(self.inFileName),'lxml')

        # Parse framerate
        frameRateDen = float(soup.profile['frame_rate_den'])
        frameRateNum = float(soup.profile['frame_rate_num'])
        frameRate = float(frameRateNum / frameRateDen)
        logging.debug("frameRate:\t%d" % frameRate)
        # TODO: check that frameRate was parsed properly

        # Parse clip data from kdenlive project file
        for producer in soup.find_all('producer'):
            logging.debug("producer:\t%s" % producer)
            if producer['id'] == 'black':
                continue

            producerID = producer['id']
            resource = producer.find('property',attrs={'name': 'resource'}).string

            # in 15.08 project file change, resource is SOMETIMES absolute.
            # Not sure the rules for this, but for now assume its relative to $HOME if pathname does not start with / (what about windows?)
            if not os.path.isabs(resource):
                resource = os.path.join(os.path.expanduser('~'),resource)

            #name = producer.find('property',attrs={'name': 'kdenlive:clipname'}).string # Not reliable anymore.. some producers don't have this property for unknown reasons.
            name = os.path.split(resource)[1]

            logging.debug("producerID: %s;\tname: %s;\tresource: %s" % (producerID, name, resource))

            # kdenlive identifies producers as <clipid>_<track> or
            # just <clipid> when on first track
            regex = "^%s_|^%s$" % (producerID, producerID)
            for clip in soup.find_all('entry', producer=re.compile(regex)):
                logging.debug("clip: %s" % clip)
                if (clip['producer'] == 'black' or
                        clip.parent.attrs['id'] == 'main bin'):
                    continue

                startFrame = int(clip['in'])
                endFrame = int(clip['out'])
                startSeconds = startFrame / frameRate
                endSeconds = endFrame / frameRate
                durationFrames = endFrame - startFrame
                durationSeconds = endSeconds - startSeconds

                # break file into name and extension
                m = re.search(r"(.+)\.(.+)$", name)
                if m:
                    fileName = m.group(1)
                    fileExtension = ".{}".format(m.group(2))
                else:
                    logging.error("could not parse file extension of '%s'" % name)
                    fileName = name
                    fileExtension = ""

                outFileName = "%s-%d-%d%s" % (fileName, int(startSeconds), int(endSeconds), fileExtension)
                outFileNamePath = os.path.join(self.outPath, outFileName)
                ffmpegCommandLine = ['ffmpeg', '-y', '-i', resource, '-ss', '%0.3f' % startSeconds, '-t', '%0.3f' % durationSeconds, '-c', 'copy', outFileNamePath]

                self.clips.append({
                    'id': producerID,
                    'name': name,
                    'resource': resource,
                    'startFrame': startFrame,
                    'endFrame': endFrame,
                    'durationFrames': durationFrames,
                    'startSeconds': startSeconds,
                    'endSeconds': endSeconds,
                    'durationSeconds': durationSeconds,
                    'ffmpegCommandLine': ffmpegCommandLine
                })

        # Execute ffmpeg commmands
        for clip in self.clips:
            ffmpegCommandLine = clip['ffmpegCommandLine']
            logging.debug("ffmpegCommandLine: %s" % str(ffmpegCommandLine))
            proc = subprocess.Popen(ffmpegCommandLine)
            proc.wait()
            if proc.returncode != 0:
                self.errorCount += 1

    def getClips(self):
        return self.clips

    def getErrorCount(self):
        return self.errorCount


if __name__ == "__main__":
    main()
